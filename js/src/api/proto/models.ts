// @generated by protobuf-ts 2.9.0 with parameter long_type_bigint,server_generic
// @generated from protobuf file "models.proto" (package "ubt", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
import { Struct } from "./google/protobuf/struct";
import { uint256 } from "./commons";
/**
 * *
 * Common currency representation.
 * Currency can be native blockchain currency, ERC-20 like token or ERC-1155 like token.
 *
 * @generated from protobuf message ubt.Currency
 */
export interface Currency {
    /**
     * *
     * Unique currency ID within the blockchain in format [contractAddress]:[tokenId].
     * For native currency - ':'
     * For ERC-20 like tokens - 'contractAddress:'
     * For ERC-1155 like tokens - 'contractAddress:tokenId'
     * For blockchain natively supported tokens (without a contract) - ':tokenId'
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * *
     * Short well known currency name like BTC, ETH, USDT etc.
     * Note that for contract based token it should be exact symbol from contract if specified
     *
     * @generated from protobuf field: string symbol = 2;
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 3;
     */
    decimals: number;
    /**
     * @generated from protobuf field: uint64 capabilities = 4;
     */
    capabilities: bigint; // bit flags for token capabilities
    /**
     * @generated from protobuf field: ubt.CurrencyMetadata metadata = 6;
     */
    metadata?: CurrencyMetadata;
}
/**
 * @generated from protobuf message ubt.CurrencyMetadata
 */
export interface CurrencyMetadata {
    /**
     * long name of the currency
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string icon_url = 2;
     */
    iconUrl: string;
}
/**
 *
 * Amount in specific currency.
 *
 * @generated from protobuf message ubt.CurrencyAmount
 */
export interface CurrencyAmount {
    /**
     * *
     * Value in minimal units
     *
     * @generated from protobuf field: ubt.uint256 value = 1;
     */
    value?: uint256;
    /**
     * @generated from protobuf field: string currency_id = 2;
     */
    currencyId: string;
}
/**
 * *
 * Blockchain instance ID.
 *
 * @generated from protobuf message ubt.ChainId
 */
export interface ChainId {
    /**
     * *
     * Network type like BTC, ETH, etc.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * *
     * Chain instance name like mainnet, testnet, etc.
     * Instance must have same chain and genesis block over the time so instead of 'testnet' it should be 'goerli', 'sepolia' etc.
     *
     * @generated from protobuf field: string network = 2;
     */
    network: string;
}
/**
 * *
 * Explorer link templates for easier viewing
 *
 * @generated from protobuf message ubt.ChainExplorerUrls
 */
export interface ChainExplorerUrls {
    /**
     * @generated from protobuf field: string block_url = 1;
     */
    blockUrl: string; // url to recommended block explorer with '{}' placeholder for block hash
    /**
     * @generated from protobuf field: string tx_url = 2;
     */
    txUrl: string; // url to recommended block explorer with '{}' placeholder for tx id
    /**
     * @generated from protobuf field: string address_url = 3;
     */
    addressUrl: string; // url to view address information with '{}' placeholder for address
}
/**
 * *
 * Blockchain instance information.
 *
 * @generated from protobuf message ubt.Chain
 */
export interface Chain {
    /**
     * @generated from protobuf field: ubt.ChainId id = 1;
     */
    id?: ChainId;
    /**
     * @generated from protobuf field: bool testnet = 3;
     */
    testnet: boolean; // indicate if this is testnet-like instance
    /**
     * @generated from protobuf field: uint32 ms_per_block = 4;
     */
    msPerBlock: number; // estimated block rate in the network
    /**
     * @generated from protobuf field: uint32 finalized_height = 5;
     */
    finalizedHeight: number; // height between block and tip when block is considered finalized
    /**
     * @generated from protobuf field: ubt.ChainExplorerUrls explorer = 6;
     */
    explorer?: ChainExplorerUrls; // recommended explorer service urls
    /**
     * @generated from protobuf field: optional uint32 bip44_id = 7;
     */
    bip44Id?: number; // BIP-44 network id
    /**
     * @generated from protobuf field: repeated ubt.Chain.ChainSupportedServices supported_services = 8;
     */
    supportedServices: Chain_ChainSupportedServices[]; // supported services
    /**
     * @generated from protobuf field: google.protobuf.Struct metadata = 15;
     */
    metadata?: Struct; // network metadata in JSON format
}
/**
 * *
 * Supported services. CbtNetworkService must be always supported.
 *
 * @generated from protobuf enum ubt.Chain.ChainSupportedServices
 */
export enum Chain_ChainSupportedServices {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: BLOCK = 1;
     */
    BLOCK = 1,
    /**
     * @generated from protobuf enum value: CURRENCIES = 2;
     */
    CURRENCIES = 2,
    /**
     * @generated from protobuf enum value: CONSTRUCT = 3;
     */
    CONSTRUCT = 3,
    /**
     * @generated from protobuf enum value: BALANCES = 4;
     */
    BALANCES = 4
}
/**
 * @generated from protobuf message ubt.Account
 */
export interface Account {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // address in human readable format
    /**
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number; // account type, if known; can be flag mask for combinations
}
/**
 * @generated from protobuf enum ubt.Account.AccountType
 */
export enum Account_AccountType {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * standard address; usually can be used to initiate transactions
     *
     * @generated from protobuf enum value: STANDARD = 1;
     */
    STANDARD = 1,
    /**
     * contract address
     *
     * @generated from protobuf enum value: CONTRACT = 2;
     */
    CONTRACT = 2
}
/**
 *
 * Small block header with only necessary information
 *
 * @generated from protobuf message ubt.BlockHeader
 */
export interface BlockHeader {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array; // unique block ID, usually block hash
    /**
     * @generated from protobuf field: uint64 number = 2;
     */
    number: bigint; // block sequential number (level/height)
    /**
     * @generated from protobuf field: bytes parent_id = 3;
     */
    parentId: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 4;
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: ubt.FinalityStatus finality_status = 5;
     */
    finalityStatus: FinalityStatus;
}
/**
 * @generated from protobuf message ubt.Block
 */
export interface Block {
    /**
     * @generated from protobuf field: ubt.BlockHeader header = 1;
     */
    header?: BlockHeader;
    /**
     * @generated from protobuf field: repeated ubt.Transaction transactions = 10;
     */
    transactions: Transaction[];
    /**
     * @generated from protobuf field: ubt.uint256 gas_limit = 12;
     */
    gasLimit?: uint256;
    /**
     * @generated from protobuf field: ubt.uint256 gas_used = 13;
     */
    gasUsed?: uint256;
}
/**
 * @generated from protobuf message ubt.Transaction
 */
export interface Transaction {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array; // unique transaction id within network;
    /**
     * @generated from protobuf field: bytes block_id = 2;
     */
    blockId: Uint8Array; // block this tx belongs to
    /**
     * @generated from protobuf field: uint32 idx = 3;
     */
    idx: number; // transaction sequence number in block
    /**
     * @generated from protobuf field: uint32 type = 4;
     */
    type: number;
    /**
     * @generated from protobuf field: string from = 5;
     */
    from: string; // account that initiated transaction;
    /**
     * @generated from protobuf field: string to = 6;
     */
    to: string; // transaction receiver
    /**
     * @generated from protobuf field: ubt.uint256 amount = 7;
     */
    amount?: uint256; // amount in native blockchain currency
    /**
     * @generated from protobuf field: ubt.uint256 fee = 8;
     */
    fee?: uint256; // actual fee in native blockchain currency
    /**
     * @generated from protobuf field: repeated ubt.Transfer transfers = 10;
     */
    transfers: Transfer[];
    /**
     * @generated from protobuf field: repeated ubt.Operation operations = 11;
     */
    operations: Operation[];
}
/**
 * *
 * Represents single transfer of any assets (in native, ERC-20 like or other token format) from one account to another.
 * Multiple transfers can be related to no operations when transfer happened just in native currency,
 * or multiple transfers can be be related to single operation in case of batch transfer calls.
 *
 * For UTXO every input and output will be listed as separate transfer with empty 'from' or 'to' correspondingly.
 *
 * Examples:
 * tx with non-zero amount which calls contract method of ERC-20 token to transfer generate 2 transfer records -
 * one for native currency, another for ERC-20 token transfer
 *
 * @generated from protobuf message ubt.Transfer
 */
export interface Transfer {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array; // id of the transfer, can be generated as tx id plus some index in transaction;
    /**
     * @generated from protobuf field: string from = 2;
     */
    from: string; // transfer source account; might be different than tx.from; omitted for minting or UTXO input
    /**
     * @generated from protobuf field: string to = 3;
     */
    to: string; // transfer destination account; might be different than tx.to; omitted for burning or UTXO output
    /**
     * @generated from protobuf field: ubt.CurrencyAmount amount = 4;
     */
    amount?: CurrencyAmount; // transfer amount; required
    /**
     * @generated from protobuf field: uint32 status = 5;
     */
    status: number; // transfer status; required
    /**
     * @generated from protobuf field: bytes tx_id = 10;
     */
    txId: Uint8Array; // transaction where this transfer happened; required
    /**
     * @generated from protobuf field: bytes op_id = 11;
     */
    opId: Uint8Array; // if transfer related to some contract operation; optional
}
/**
 * *
 * Represents operation within transactions. Usually contract calls.
 * Operations like ERC-20 transfer will be shown in both places - as operation and as transfer
 *
 * @generated from protobuf message ubt.Operation
 */
export interface Operation {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: ubt.Account contract = 2;
     */
    contract?: Account;
    /**
     * @generated from protobuf field: uint32 type = 3;
     */
    type: number;
}
/**
 *
 * Indicate reorg safety status of the block.
 *
 * @generated from protobuf enum ubt.FinalityStatus
 */
export enum FinalityStatus {
    /**
     * @generated from protobuf enum value: FINALITY_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * there is a chance that block will not be included or reverted
     *
     * @generated from protobuf enum value: FINALITY_STATUS_UNSAFE = 1;
     */
    UNSAFE = 1,
    /**
     * less chance
     *
     * @generated from protobuf enum value: FINALITY_STATUS_SAFE = 2;
     */
    SAFE = 2,
    /**
     * @generated from protobuf enum value: FINALITY_STATUS_FINALIZED = 3;
     */
    FINALIZED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Currency$Type extends MessageType<Currency> {
    constructor() {
        super("ubt.Currency", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "capabilities", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "metadata", kind: "message", T: () => CurrencyMetadata }
        ]);
    }
    create(value?: PartialMessage<Currency>): Currency {
        const message = { id: "", symbol: "", decimals: 0, capabilities: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Currency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Currency): Currency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                case /* uint32 decimals */ 3:
                    message.decimals = reader.uint32();
                    break;
                case /* uint64 capabilities */ 4:
                    message.capabilities = reader.uint64().toBigInt();
                    break;
                case /* ubt.CurrencyMetadata metadata */ 6:
                    message.metadata = CurrencyMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Currency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.symbol);
        /* uint32 decimals = 3; */
        if (message.decimals !== 0)
            writer.tag(3, WireType.Varint).uint32(message.decimals);
        /* uint64 capabilities = 4; */
        if (message.capabilities !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.capabilities);
        /* ubt.CurrencyMetadata metadata = 6; */
        if (message.metadata)
            CurrencyMetadata.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Currency
 */
export const Currency = new Currency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyMetadata$Type extends MessageType<CurrencyMetadata> {
    constructor() {
        super("ubt.CurrencyMetadata", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "icon_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CurrencyMetadata>): CurrencyMetadata {
        const message = { name: "", iconUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrencyMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyMetadata): CurrencyMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string icon_url */ 2:
                    message.iconUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrencyMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string icon_url = 2; */
        if (message.iconUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iconUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.CurrencyMetadata
 */
export const CurrencyMetadata = new CurrencyMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyAmount$Type extends MessageType<CurrencyAmount> {
    constructor() {
        super("ubt.CurrencyAmount", [
            { no: 1, name: "value", kind: "message", T: () => uint256 },
            { no: 2, name: "currency_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CurrencyAmount>): CurrencyAmount {
        const message = { currencyId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrencyAmount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyAmount): CurrencyAmount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ubt.uint256 value */ 1:
                    message.value = uint256.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* string currency_id */ 2:
                    message.currencyId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrencyAmount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ubt.uint256 value = 1; */
        if (message.value)
            uint256.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string currency_id = 2; */
        if (message.currencyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.currencyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.CurrencyAmount
 */
export const CurrencyAmount = new CurrencyAmount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainId$Type extends MessageType<ChainId> {
    constructor() {
        super("ubt.ChainId", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChainId>): ChainId {
        const message = { type: "", network: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChainId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainId): ChainId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string network */ 2:
                    message.network = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string network = 2; */
        if (message.network !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.network);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.ChainId
 */
export const ChainId = new ChainId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainExplorerUrls$Type extends MessageType<ChainExplorerUrls> {
    constructor() {
        super("ubt.ChainExplorerUrls", [
            { no: 1, name: "block_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tx_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChainExplorerUrls>): ChainExplorerUrls {
        const message = { blockUrl: "", txUrl: "", addressUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChainExplorerUrls>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainExplorerUrls): ChainExplorerUrls {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string block_url */ 1:
                    message.blockUrl = reader.string();
                    break;
                case /* string tx_url */ 2:
                    message.txUrl = reader.string();
                    break;
                case /* string address_url */ 3:
                    message.addressUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainExplorerUrls, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string block_url = 1; */
        if (message.blockUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.blockUrl);
        /* string tx_url = 2; */
        if (message.txUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.txUrl);
        /* string address_url = 3; */
        if (message.addressUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.addressUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.ChainExplorerUrls
 */
export const ChainExplorerUrls = new ChainExplorerUrls$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chain$Type extends MessageType<Chain> {
    constructor() {
        super("ubt.Chain", [
            { no: 1, name: "id", kind: "message", T: () => ChainId },
            { no: 3, name: "testnet", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ms_per_block", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "finalized_height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "explorer", kind: "message", T: () => ChainExplorerUrls },
            { no: 7, name: "bip44_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "supported_services", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ubt.Chain.ChainSupportedServices", Chain_ChainSupportedServices] },
            { no: 15, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Chain>): Chain {
        const message = { testnet: false, msPerBlock: 0, finalizedHeight: 0, supportedServices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Chain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chain): Chain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ubt.ChainId id */ 1:
                    message.id = ChainId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* bool testnet */ 3:
                    message.testnet = reader.bool();
                    break;
                case /* uint32 ms_per_block */ 4:
                    message.msPerBlock = reader.uint32();
                    break;
                case /* uint32 finalized_height */ 5:
                    message.finalizedHeight = reader.uint32();
                    break;
                case /* ubt.ChainExplorerUrls explorer */ 6:
                    message.explorer = ChainExplorerUrls.internalBinaryRead(reader, reader.uint32(), options, message.explorer);
                    break;
                case /* optional uint32 bip44_id */ 7:
                    message.bip44Id = reader.uint32();
                    break;
                case /* repeated ubt.Chain.ChainSupportedServices supported_services */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedServices.push(reader.int32());
                    else
                        message.supportedServices.push(reader.int32());
                    break;
                case /* google.protobuf.Struct metadata */ 15:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ubt.ChainId id = 1; */
        if (message.id)
            ChainId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool testnet = 3; */
        if (message.testnet !== false)
            writer.tag(3, WireType.Varint).bool(message.testnet);
        /* uint32 ms_per_block = 4; */
        if (message.msPerBlock !== 0)
            writer.tag(4, WireType.Varint).uint32(message.msPerBlock);
        /* uint32 finalized_height = 5; */
        if (message.finalizedHeight !== 0)
            writer.tag(5, WireType.Varint).uint32(message.finalizedHeight);
        /* ubt.ChainExplorerUrls explorer = 6; */
        if (message.explorer)
            ChainExplorerUrls.internalBinaryWrite(message.explorer, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 bip44_id = 7; */
        if (message.bip44Id !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.bip44Id);
        /* repeated ubt.Chain.ChainSupportedServices supported_services = 8; */
        if (message.supportedServices.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedServices.length; i++)
                writer.int32(message.supportedServices[i]);
            writer.join();
        }
        /* google.protobuf.Struct metadata = 15; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Chain
 */
export const Chain = new Chain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account$Type extends MessageType<Account> {
    constructor() {
        super("ubt.Account", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Account>): Account {
        const message = { id: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account): Account {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Account
 */
export const Account = new Account$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockHeader$Type extends MessageType<BlockHeader> {
    constructor() {
        super("ubt.BlockHeader", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "parent_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 5, name: "finality_status", kind: "enum", T: () => ["ubt.FinalityStatus", FinalityStatus, "FINALITY_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<BlockHeader>): BlockHeader {
        const message = { id: new Uint8Array(0), number: 0n, parentId: new Uint8Array(0), finalityStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockHeader): BlockHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* uint64 number */ 2:
                    message.number = reader.uint64().toBigInt();
                    break;
                case /* bytes parent_id */ 3:
                    message.parentId = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 4:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* ubt.FinalityStatus finality_status */ 5:
                    message.finalityStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* uint64 number = 2; */
        if (message.number !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.number);
        /* bytes parent_id = 3; */
        if (message.parentId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.parentId);
        /* google.protobuf.Timestamp timestamp = 4; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ubt.FinalityStatus finality_status = 5; */
        if (message.finalityStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.finalityStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.BlockHeader
 */
export const BlockHeader = new BlockHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Block$Type extends MessageType<Block> {
    constructor() {
        super("ubt.Block", [
            { no: 1, name: "header", kind: "message", T: () => BlockHeader },
            { no: 10, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction },
            { no: 12, name: "gas_limit", kind: "message", T: () => uint256 },
            { no: 13, name: "gas_used", kind: "message", T: () => uint256 }
        ]);
    }
    create(value?: PartialMessage<Block>): Block {
        const message = { transactions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Block>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Block): Block {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ubt.BlockHeader header */ 1:
                    message.header = BlockHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated ubt.Transaction transactions */ 10:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* ubt.uint256 gas_limit */ 12:
                    message.gasLimit = uint256.internalBinaryRead(reader, reader.uint32(), options, message.gasLimit);
                    break;
                case /* ubt.uint256 gas_used */ 13:
                    message.gasUsed = uint256.internalBinaryRead(reader, reader.uint32(), options, message.gasUsed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Block, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ubt.BlockHeader header = 1; */
        if (message.header)
            BlockHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ubt.Transaction transactions = 10; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* ubt.uint256 gas_limit = 12; */
        if (message.gasLimit)
            uint256.internalBinaryWrite(message.gasLimit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* ubt.uint256 gas_used = 13; */
        if (message.gasUsed)
            uint256.internalBinaryWrite(message.gasUsed, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Block
 */
export const Block = new Block$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("ubt.Transaction", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "block_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "amount", kind: "message", T: () => uint256 },
            { no: 8, name: "fee", kind: "message", T: () => uint256 },
            { no: 10, name: "transfers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transfer },
            { no: 11, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Operation }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { id: new Uint8Array(0), blockId: new Uint8Array(0), idx: 0, type: 0, from: "", to: "", transfers: [], operations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* bytes block_id */ 2:
                    message.blockId = reader.bytes();
                    break;
                case /* uint32 idx */ 3:
                    message.idx = reader.uint32();
                    break;
                case /* uint32 type */ 4:
                    message.type = reader.uint32();
                    break;
                case /* string from */ 5:
                    message.from = reader.string();
                    break;
                case /* string to */ 6:
                    message.to = reader.string();
                    break;
                case /* ubt.uint256 amount */ 7:
                    message.amount = uint256.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* ubt.uint256 fee */ 8:
                    message.fee = uint256.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* repeated ubt.Transfer transfers */ 10:
                    message.transfers.push(Transfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ubt.Operation operations */ 11:
                    message.operations.push(Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* bytes block_id = 2; */
        if (message.blockId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.blockId);
        /* uint32 idx = 3; */
        if (message.idx !== 0)
            writer.tag(3, WireType.Varint).uint32(message.idx);
        /* uint32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).uint32(message.type);
        /* string from = 5; */
        if (message.from !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.from);
        /* string to = 6; */
        if (message.to !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.to);
        /* ubt.uint256 amount = 7; */
        if (message.amount)
            uint256.internalBinaryWrite(message.amount, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* ubt.uint256 fee = 8; */
        if (message.fee)
            uint256.internalBinaryWrite(message.fee, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated ubt.Transfer transfers = 10; */
        for (let i = 0; i < message.transfers.length; i++)
            Transfer.internalBinaryWrite(message.transfers[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated ubt.Operation operations = 11; */
        for (let i = 0; i < message.operations.length; i++)
            Operation.internalBinaryWrite(message.operations[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transfer$Type extends MessageType<Transfer> {
    constructor() {
        super("ubt.Transfer", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "message", T: () => CurrencyAmount },
            { no: 5, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tx_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "op_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Transfer>): Transfer {
        const message = { id: new Uint8Array(0), from: "", to: "", status: 0, txId: new Uint8Array(0), opId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transfer): Transfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* string from */ 2:
                    message.from = reader.string();
                    break;
                case /* string to */ 3:
                    message.to = reader.string();
                    break;
                case /* ubt.CurrencyAmount amount */ 4:
                    message.amount = CurrencyAmount.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* uint32 status */ 5:
                    message.status = reader.uint32();
                    break;
                case /* bytes tx_id */ 10:
                    message.txId = reader.bytes();
                    break;
                case /* bytes op_id */ 11:
                    message.opId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* string from = 2; */
        if (message.from !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.from);
        /* string to = 3; */
        if (message.to !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.to);
        /* ubt.CurrencyAmount amount = 4; */
        if (message.amount)
            CurrencyAmount.internalBinaryWrite(message.amount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 5; */
        if (message.status !== 0)
            writer.tag(5, WireType.Varint).uint32(message.status);
        /* bytes tx_id = 10; */
        if (message.txId.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.txId);
        /* bytes op_id = 11; */
        if (message.opId.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.opId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Transfer
 */
export const Transfer = new Transfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("ubt.Operation", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract", kind: "message", T: () => Account },
            { no: 3, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { id: new Uint8Array(0), type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* ubt.Account contract */ 2:
                    message.contract = Account.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                case /* uint32 type */ 3:
                    message.type = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* ubt.Account contract = 2; */
        if (message.contract)
            Account.internalBinaryWrite(message.contract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).uint32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ubt.Operation
 */
export const Operation = new Operation$Type();
